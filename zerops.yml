# Zerops configuration for Frappe/ERPNext deployment
# Creates managed database services and uses Docker Compose for application containers

# Managed Services have to be executed in Zerops GUI using 'Import services'
services:
    - hostname: mariadb
      # service type and version number in mariadb@{version} format
      type: mariadb@10.6
      # mode of operation "HA"/"NON_HA",
      mode: NON_HA

    - hostname: rediscache
      type: valkey@7.2
      mode: NON_HA  # use HA in production
    
    - hostname: redisqueue
      type: valkey@7.2
      mode: NON_HA  # use HA in production

    - hostname: sharedstorage
      type: shared-storage
      mode: NON_HA

zerops:
  # Frappe/ERPNext Application Services (Docker Compose)
  - setup: erpnext
    build:
      # Build custom ERPNext image with XML Importer
      base: alpine@3.19
      buildCommands:
        # Install Docker and Docker Compose with sudo
        - sudo apk update
        - sudo apk add --no-cache docker docker-compose
        - sudo rc-update add docker boot
        # Add current user to docker group for socket access
        - sudo addgroup $(whoami) docker
        - sudo service docker start || sudo dockerd &
        # Wait for Docker daemon to be ready
        - sleep 5
        # Fix docker socket permissions
        - sudo chmod 666 /var/run/docker.sock
        # Build and push to Docker Hub (use timestamp as fallback for tag)
        - export BUILD_TAG=${ZEROPS_SUBDOMAIN_PORT:-$(date +%Y%m%d-%H%M%S)}
        - docker build -f images/herbatica/erpnext/Containerfile -t davidu98/herbatica-erpnext:$BUILD_TAG .
        - docker tag davidu98/herbatica-erpnext:$BUILD_TAG davidu98/herbatica-erpnext:latest
        # Login and push to Docker Hub
        - echo $DOCKERHUB_TOKEN | docker login -u davidu98 --password-stdin
        - docker push davidu98/herbatica-erpnext:$BUILD_TAG
        - docker push davidu98/herbatica-erpnext:latest
      deployFiles: 
        - ./docker-compose.zerops.yaml
        - ./scripts/
      addToRunPrepare: 
        - ./docker-compose.zerops.yaml
        - ./scripts/
    run:
      # Environment variables for Docker Compose services
      envVariables:
        # Image configuration  
        CUSTOM_IMAGE: davidu98/herbatica-erpnext
        CUSTOM_TAG: latest
        
        # Docker Hub authentication
        DOCKERHUB_TOKEN: ${DOCKERHUB_TOKEN}
        ERPNEXT_VERSION: v15.84.0
        PULL_POLICY: always
        RESTART_POLICY: unless-stopped
        
        # Database connection (using Zerops service)
        DB_HOST: ${mariadb_hostname}
        DB_PORT: 3306
        ROOT_USER: ${mariadb_user}
        DB_PASSWORD: ${mariadb_password}

        # Redis connections (using Zerops Valkey services)
        REDIS_CACHE: rediscache:6379
        REDIS_QUEUE: redisqueue:6379

        # Site configuration
        FRAPPE_SITE_NAME_HEADER: ${siteName}
        ADMIN_PASSWORD: ${adminPassword}
        
        # Frontend/Nginx configuration
        UPSTREAM_REAL_IP_ADDRESS: 127.0.0.1
        UPSTREAM_REAL_IP_HEADER: X-Forwarded-For
        UPSTREAM_REAL_IP_RECURSIVE: "off"
        PROXY_READ_TIMEOUT: 120
        CLIENT_MAX_BODY_SIZE: 50m
      
      # Site initialization and app installation
      prepareCommands:
        # Pull all Docker images (including custom image from Docker Hub)
        - docker compose -f docker-compose.zerops.yaml pull
        
        # Step 1: Prepare shared storage
        - |
          echo "üìÅ STEP 1: Shared Storage Preparation"
          chmod +x scripts/prepare-storage.sh
          ./scripts/prepare-storage.sh
        
        # Step 2: Check service connections
        - |
          echo "ÔøΩ STEP 2: Service Connection Validation"
          chmod +x scripts/check-services.sh
          ./scripts/check-services.sh
        
        # Step 3: Install Frappe site and apps (idempotent)
        - |
          echo "üèóÔ∏è STEP 3: Frappe Site Installation (idempotent)"
          chmod +x scripts/install-frappe.sh
          ./scripts/install-frappe.sh
        
        # Step 4: Post-installation verification
        - |
          echo "‚úÖ STEP 4: Post-Installation Verification"
          chmod +x scripts/post-install-check.sh
          ./scripts/post-install-check.sh
      
      # Start all application services
      start: docker compose -f docker-compose.zerops.yaml up --force-recreate
      
      # Expose the frontend port
      ports:
        - port: 8080
          httpSupport: true

# Required secrets in Zerops dashboard:
# - dbPassword: Database password for MariaDB (e.g., "mySecureDbPassword123")
# - adminPassword: ERPNext admin user password (e.g., "myAdminPassword123")
# - siteName: Your site domain name (e.g., "mycompany.example.com")
#
# This configuration provides:
# ‚úÖ Managed MariaDB service with automatic backups and scaling
# ‚úÖ Dedicated Redis services for cache and queue (better performance)
# ‚úÖ Shared storage service for persistent data across deployments
# ‚úÖ Docker Compose for Frappe containers only (simpler, faster)
# ‚úÖ Modular installation process with dedicated scripts for each step
# ‚úÖ Automatic site initialization with custom apps
# ‚úÖ Service health monitoring and auto-restart
# ‚úÖ Built-in service discovery (services connect by name)
#
# Architecture:
# - mariadb: Managed MariaDB 10.6 service (NON_HA mode)
# - rediscache: Managed Valkey 7.2 service (NON_HA mode)  
# - redisqueue: Managed Valkey 7.2 service (NON_HA mode)
# - sharedstorage: Managed shared storage for persistent site data
# - erpnext: Docker Compose with Frappe containers (backend, frontend, websocket, workers, scheduler)
#
# Installation Process (Modular Scripts):
# 1. prepare-storage.sh - Sets up shared storage with proper permissions
# 2. check-services.sh - Validates all service connections (DB, Redis, Storage)
# 3. install-frappe.sh - Creates site and installs ERPNext + custom apps
# 4. post-install-check.sh - Verifies installation success and data persistence
#
# Benefits of managed services:
# - Automatic backups and point-in-time recovery
# - Built-in monitoring and alerting
# - Automatic security updates
# - High availability and failover
# - Performance optimization
# - No container overhead for databases